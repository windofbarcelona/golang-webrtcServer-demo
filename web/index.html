<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>WebRTC 音频回环 Demo</title>
<style>
  body { font-family: sans-serif; padding: 20px; }
  button { padding: 6px 12px; margin-right: 10px; }
  #log { white-space: pre-wrap; border: 1px solid #ccc; padding: 10px; height: 200px; overflow: auto; margin-top: 10px; }
</style>
</head>
<body>
<h2>WebRTC 音频回环 Demo</h2>
<button id="startBtn">开始</button>
<button id="stopBtn">停止</button>
<div id="log"></div>

<script>
const logEl = document.getElementById('log');
function log(...args) {
  logEl.textContent += args.join(' ') + '\n';
  logEl.scrollTop = logEl.scrollHeight;
}

let pc = null;
let localStream = null;
let remoteAudio = null;


document.getElementById('startBtn').onclick = async () => {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    log('获取本地音频流');

    // 提前创建一个 audio 元素，确保用户点击触发
    remoteAudio = document.createElement('audio');
    remoteAudio.autoplay = true;
    remoteAudio.controls = true;
    remoteAudio.muted = false;
    remoteAudio.play().catch(err => log('播放失败:', err));
    document.body.appendChild(remoteAudio);

    pc = new RTCPeerConnection({
      iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }, {
        urls:       ["turn:115.190.139.89:3478"],
        username:   "uwebrtc",
        credential: "prtcweb",
      }]
    }); 
    setInterval(async () => {
      if (!pc) return;
      const stats = await pc.getStats();
      stats.forEach(report => {
        if (report.type === "inbound-rtp" && report.kind === "audio") {
          console.log("Inbound packetsReceived:", report.packetsReceived);
          console.log("Inbound bytesReceived:", report.bytesReceived);
        }
      });
    }, 2000);
    pc.ontrack = (event) => {
      log('收到远端音频 track');
      remoteAudio.srcObject = event.streams[0]; // 🔑 直接复用已有 audio
    };

    for (const track of localStream.getAudioTracks()) {
      pc.addTrack(track, localStream);
    }

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const response = await fetch('/offer', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type: offer.type, sdp: offer.sdp })
    });

    const answer = await response.json();
    await pc.setRemoteDescription(answer);
    log('设置远端 Answer 完成，回环建立'); 

    pc.onconnectionstatechange = () => {
      log('PeerConnection 状态: ' + pc.connectionState);
    };

    // 监听 ICE 候选的变化
    pc.onicecandidate = function (event) {
      console.log('ICE Candidate: ', event.candidate);
      if (event.candidate) {
        console.log('ICE Candidate: ', event.candidate);
        // 将 ICE candidate 发送到服务器
        // sendCandidateToServer(event.candidate);
      } else {
        console.log('ICE candidate gathering complete');
      }
    };
    // 监听 ICE 连接状态变化
    pc.oniceconnectionstatechange = function (event) {
      console.log(
        'ICE Connection State has changed: ',
        pc.iceConnectionState,
      );
      // 可以根据状态处理逻辑，例如连接失败时重新尝试连接
      if (pc.iceConnectionState === 'failed') {
        console.log(
          'ICE Connection failed. Please check the network and NAT configuration.',
        );
      }
    };
    // 监听 ICE Gathering 状态变化
    pc.onicegatheringstatechange = function (event) {
      console.log(
        'ICE Gathering State has changed: ',
        pc.iceGatheringState,
      );
      // 如果需要，可以在此处理特定的收集状态，如 `gathering` 或 `complete`
      if (pc.iceGatheringState === 'complete') {
        console.log('ICE gathering completed.');
      }
    };

  } catch (err) {
    log('错误:', err);
  }
};

document.getElementById('stopBtn').onclick = () => {
  if (localStream) {
    localStream.getTracks().forEach(t => t.stop());
    localStream = null;
  }
  if (pc) {
    pc.close();
    pc = null;
  }
  log('停止回环');
};
</script>
</body>
</html>
